\documentclass[12pt]{article}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{multicol}
\usepackage[latin1]{inputenc}
\usepackage{listings}
\usepackage{scrextend}
\usepackage{changepage} %Adjustwidth
\usepackage{float}

\usepackage{algorithm}
\usepackage{algorithmic}


\title{ComS 311\\Recitation 3, 2:00 Monday\\Homework 4}
\author{Sean Gordon}
%\date{09/29/2019}

\begin{document}
\maketitle


\begin{algorithm}[H]
\caption{Define G$^2$ from G using paths of length 2, excluding cycles.}
\begin{algorithmic}
\REQUIRE G is provided as an adjacency list'.
\STATE Assume G is stored in ``G"

\STATE
\STATE Create empty adjacency list named ``G2''
\STATE

\STATE \#For every vertex...
\FORALL{list in G}
\STATE start = current vertex
\STATE G2.add(start)
\STATE
\STATE \#For every vertex this points to...
\FORALL{vertex in list}
\STATE innerList = G.get(vertex)
\STATE
\STATE \#For every vertex that that vertex points to...
\FORALL{boof}

\STATE
\STATE \#If this vertex is the start (u == v)
\IF{vertex == start}
\STATE continue
\ENDIF
\STATE
\STATE \#Add this edge (of length 2) to the new graph
\STATE G2.get(start).add(vertex)

\ENDFOR
\ENDFOR
\ENDFOR
\STATE

\STATE The runtime of this algorithm is
\STATE 1st-Loop(V) * 2nd-Loop(E) * 3rd-Loop(V): O(V$^2$*E)
\end{algorithmic}
\end{algorithm}




\pagebreak


\begin{algorithm}[H]
\caption{Find the number of shortest paths from s to vertex i.}
\begin{algorithmic}
\STATE Assume G is stored in adjacency list ``G"

\STATE 
\STATE Create object \textit{Pair} that stores two Integers
\STATE Create an array \textit{paths} of size V
\STATE The array will store \textit{path length} and \textit{count} for each vertex in a \textit{Pair} obj
\STATE
\STATE //Perform breadth first search on the graph -----------------------------------
\STATE
\STATE //Create a queue for BFS that holds \textit{depth} and the \textit{vertex} in a \textit{Pair}
\STATE LinkedList$<$Pair$>$ queue = new LinkedList$<$Pair$>$();
\STATE boolean visited = new boolean[V];
\STATE
\STATE //Mark the current node as visited, add it to the array, and enqueue it 
\STATE visited[s] = true; 
\STATE paths[s] = new Pair(0, 1);
\STATE queue.add(new Pair(0, s)); 
\STATE
\WHILE {queue.size() != 0}
\STATE //Dequeue a vertex
\STATE Pair pair = queue.poll(); 
\STATE int depth = vertex.depth;
\STATE int vertex = vertex.node;
\STATE
\STATE Iterator iterator = G[vertex].listIterator();
\WHILE {iterator.hasNext()}
\STATE int v = iterator.next(); 
\STATE
\IF {!visited[v]}
\STATE visited[v] = true; 
\STATE paths[s] = new Pair(depth+1, 1);
\STATE queue.add(new Pair(depth+1, v));
\STATE
\ELSIF {paths[v].length == depth+1}
\STATE //If this depth == the one already stored, this is a shortest path
\STATE paths[v].count = paths[v].count + 1;
\ENDIF
\ENDWHILE
\ENDWHILE
\STATE return paths[i].count;

\end{algorithmic}
\end{algorithm}
Honestly I have no idea how to induction this crap lol\\
\noindent Runtime for above algorithm: \\
1 while loop through each vertex $\Rightarrow$ O(V)\\
1 while loop through each edge of each vertex $\Rightarrow$ O(E)\\
These two combine to become O(V+E)



\pagebreak


\noindent 3a) \textit{Prove that every DAG (Directed Acyclic Graph) has a sink.}\\
Let G be a directed graph with number of verticies n, each with at least one outgoing edge. To prove the claim we show that if there is no sink, there must be a cycle. \\
Picking any vertex u, we begin to follow each edge outward. If there are no sinks, we will be able to continue to node v, then w, and so on. However, with a graph of order n, we must eventually reach a previously seen vertex after at most n+1 steps. This is clearly a cycle, breaking the acyclic assumption made earlier.\\

\begin{algorithm}[H]
\caption{Compute topological ordering of a DAG.}
\begin{algorithmic}
\STATE Assume G is stored in adjacency list ``G"

\STATE 
\STATE Create object \textit{Pair} that stores two Integers
\STATE Create an array \textit{paths} of size V
\STATE The array will store \textit{path length} and \textit{count} for each vertex in a \textit{Pair} obj
\STATE
\STATE //Perform breadth first search on the graph -----------------------------------
\STATE
\STATE //Create a queue for BFS that holds \textit{depth} and the \textit{vertex} in a \textit{Pair}
\STATE LinkedList$<$Pair$>$ queue = new LinkedList$<$Pair$>$();
\STATE boolean visited = new boolean[V];
\STATE
\STATE //Mark the current node as visited, add it to the array, and enqueue it 
\STATE visited[s] = true; 
\STATE paths[s] = new Pair(0, 1);
\STATE queue.add(new Pair(0, s)); 
\STATE
\WHILE {queue.size() != 0}
\STATE //Dequeue a vertex
\STATE Pair pair = queue.poll(); 
\STATE int depth = vertex.depth;
\STATE int vertex = vertex.node;
\STATE
\STATE Iterator iterator = G[vertex].listIterator();
\WHILE {iterator.hasNext()}
\STATE int v = iterator.next(); 
\STATE
\IF {!visited[v]}
\STATE visited[v] = true; 
\STATE paths[s] = new Pair(depth+1, 1);
\STATE queue.add(new Pair(depth+1, v));
\STATE
\ELSIF {paths[v].length == depth+1}
\STATE //If this depth == the one already stored, this is a shortest path
\STATE paths[v].count = paths[v].count + 1;
\ENDIF
\ENDWHILE
\ENDWHILE
\STATE return paths[i].count;

\end{algorithmic}
\end{algorithm}

\pagebreak

4) \\
Goddamnit


%\begin{lstlisting}
%\end{lslisting}
\end{document}